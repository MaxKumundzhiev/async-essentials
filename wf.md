# Wunder Fund reads
Рассмотрим
- Определение, создание и запуск корутин.
- Асинхронное программирование в Python.
- Организация неблокирующего ввода-вывода.
- Средства конкурентного программирования, используемые при работе с корутинами.

### Асинхронные задачи
Слово «асинхронный» используют для описания неких процессов, не совпадающих друг с другом во времени. Его противоположность — слово «синхронный», используемое для описания чего-либо, точно совпадающего во времени.

### Асинхронный вызов функции
Асинхронный вызов функции — это запрос на вызов функции, выполняемый неким образом в некий момент времени, при этом вызывающая сторона, после выполнения вызова, может продолжать работу и решать другие задачи.

### Объект future
Выполнение асинхронного вызова функции часто приводит к предоставлении вызывающей стороне некоего идентификатора запроса, который вызывающая сторона может использовать для того, чтобы проверить состояние запроса или получить результаты. Такие идентификаторы часто называют объектами, ждущими результата выполнения задачи (future, объект Future, преднамеченное значение, «футура»).

Объект future: идентификатор асинхронного вызова функции, позволяющий проверять состояние вызова и получать результаты работы функции.

### Объект task
Комбинацию асинхронного вызова функции и объекта Future часто называют асинхронной задачей. Это так из-за того, что такая комбинация даёт больше возможностей, чем обычный вызов функции. Например — позволяет отменять запрос и выполнять другие действия.

Асинхронная задача: этот термин используется для обозначения сущности, представляющей собой объединение асинхронного вызова функции и порождённого этим вызовом объекта Future.

### Асинхронное программирование
В широком смысле асинхронное программирование в Python — это выполнение запросов без блокировки основной программы ради ожидания их завершения. Всё это реализовано с использованием корутин. Они выполняются в `цикле событий, а сам он выполняется в единственном потоке`.

Если говорить о других подобных механизмах — то в Python можно работать с потоками и процессами, которые способны асинхронно выполнять задачи. Например, один поток может запустить другой поток для выполнения вызова функции, а после этого продолжить выполнять другие действия. Операционная система запланирует и выполнит второй поток в некий момент времени, а первый поток может, по желанию программиста, проверить состояние задачи, или может этого не делать.

Python даёт в наше распоряжение пулы потоков и процессов, основанные на концепции исполнителей. Реализовано это, соответственно, посредством классов ThreadPoolExecutor и ProcessPoolExecutor. Эти классы используют одинаковый интерфейс и поддерживают асинхронные задачи с помощью метода submit(), который возвращает объект Future.

### Корутины
Корутина — это функция, выполнение которой можно приостановить и возобновить.

Корутину можно определить с использованием выражения async def. Она может принимать аргументы и возвращать значение — так же, как и функция.
```python
async def coro():
    ...

...
создание объекта корутины
coro = custom_coro()

...
приостановить выполнение кода и запланировать выполнение целевого объекта
await custom_coro()
```

Асинхронный итератор — это итератор, который выдаёт объекты, допускающие ожидание.
> Асинхронный итератор: объект, который реализует методы aiter() и anext(). Метод anext() должен возвращать объект, допускающий ожидание. Конструкция async for разрешает объекты, допускающие ожидание, возвращённые методом anext() асинхронного итератора до тех пор, пока он не вызовет исключение StopAsyncIteration.
```python
...
обход асинхронного итератора
async for item in async_iterator:
    print(item)
```
> Применение этой конструкции не приводит к параллельному выполнению цикла for. Вместо этого вызывающая корутина, которая выполняет цикл for, будет приостанавливаться и самостоятельно ожидать каждый объект, допускающий ожидание, полученный из итератора.


## asyncio
Центральной концепцией модуля asyncio является цикл событий. Это — механизм, который выполняет программы, основанные на корутинах, и реализует кооперативную многозадачность корутин.

Когда стоит использовать модуль asyncio:
    - Чтобы применять в программе корутины.
    - Чтобы воспользоваться парадигмой асинхронного программирования.
    - Чтобы использовать неблокирующую обработку ввода/вывода.

> Конкурентность, основанная на потоках, доступна Python-программистам благодаря модулю threading, она поддерживается на уровне операционной системы, в которой работает Python-программа. Такая конкурентность подходит для обработки блокирующих операций ввода/вывода, таких, как запись и чтение данных при работе с файлами, сокетами, устройствами.

> Конкурентность, основанная на процессах, реализуется на основе механизмов из модуля multiprocessing. Её, как и в случае с потоками, поддерживает операционная система. Она подходит для решения задач, скорость выполнения которых привязана к производительности CPU, но которые при этом не предусматривают интенсивного межпроцессного взаимодействия. Это, например, тяжёлые вычислительные задачи.

> Корутины — это альтернатива потокам и процессам. Программисту их предоставляет сам язык Python и среда его выполнения (стандартный интерпретатор), а их поддержка основана на модуле asyncio. Они подходят для обработки неблокируюих операций ввода/вывода с использованием подпроцессов и сокетов. Впрочем, заниматься блокирующим вводом/выводом и решать тяжёлые вычислительные задачи можно, используя подход, имитирующий решение неблокирующих задач, когда в недрах программы всё сводится к применению потоков и процессов.


```
Потоки и процессы позволяют достичь многозадачности через механизмы операционной системы, которая решает — какой поток или процесс надо запустить, когда его надо запустить, сколько процессорного времени ему дать. Операционная система быстро переключается между потоками и процессами, приостанавливая те, которые отработали отведённое им время, и возобновляя выполнение тех, которым выделено время на работу. Это называют вытесняющей многозадачностью.

А корутины в Python реализуют альтернативный подход к многозадачности — кооперативную многозадачность. Корутины — это подпрограммы (функции), выполнение которых можно приостанавливать и возобновлять. Их выполнение приостанавливается с помощью выражения await, а возобновляется после того, как это выражение разрешится. Корутины задуманы именно такими, это позволяет им кооперироваться, решая — когда и где приостановить выполнение.

Они «легче» потоков. То есть — быстрее запускаются и используют меньше памяти. В сущности, корутины — это особая разновидность функций, а вот потоки представлены Python-объектами и связаны с потоками в операционной системе, с которыми эти объекты должны взаимодействовать.

В силу этого в Python-программе могут использоваться тысячи потоков. А если говорить о корутинах, то их уже может быть десятки или сотни тысяч, все они будут размещены в одном потоке.
```

```
Как мы уже видели, корутины могут выполнять неблокирующие операции ввода/вывода асинхронно. Но модуль asyncio, кроме того, даёт нам возможность выполнять в асинхронном стиле блокирующие операции ввода/вывода и задачи, скорость выполнения которых привязана к производительности CPU. Делается это путём имитации неблокирующих механизмов в недрах системы посредством потоков и процессов.
```


## Еще про корутины
Корутина (coroutine, сопрограмма) — это функция, выполнение которой может быть приостановлено и возобновлено. Подпрограмму можно запустить, её работа начнётся в одном месте и завершится в другом. А корутину можно запустить, потом — приостановить, потом — возобновить. Приостанавливать и возобновлять выполнение корутины можно много раз — до того момента, пока её работа не будет, в итоге, завершена. В частности, корутины могут управлять тем, где именно они приостанавливают своё выполнение. Для этого может привлекаться специфическое выражение — такое, как await, похожее на выражение yield, применяемое в Python-генераторах.

Одновременно можно создавать и запускать множество корутин. У них есть `средства управления` тем, когда они `приостанавливают и возобновляют` своё выполнение, что позволяет им `кооперироваться относительно того, когда выполняются конкурентные задачи`. Это называют `кооперативной многозадачностью`. Такой подход к многозадачности `отличается от вытесняющей многозадачности`, обычно используемой при работе с потоками.

> …для организации конкурентного выполнения множества приложений `процессы добровольно уступают контроль другим приложениям`, делая это либо через некие промежутки времени, либо тогда, когда они простаивают или логически заблокированы. Этот тип многозадачности называют кооперативной многозадачностью из-за того, что все программы должны кооперироваться для того чтобы обеспечить работу схемы планирования их выполнения.

> Реализация `вытесняющей многозадачности` предусматривает участие `операционной системы в принятии решений` о том, какой поток и когда нужно приостановить или возобновить. Это отличается от подхода, применяемого в кооперативной многозадачности, когда задачи сами принимают подобные решения.


### Сравнение корутин и задач
Подпрограммы и корутины могут представлять в программах «задачи». Но в Python есть особый объект, представляющий задачу. Это — объект asyncio.Task.
Корутину можно обернуть в объект asyncio.Task и выполнить независимо — в противовес её выполнению напрямую, внутри другой корутины. Объект Task даёт средства для асинхронного выполнения корутин.

Задача: обёрнутая корутина, которая может быть выполнена независимо.
Это позволяет обёрнутой корутине выполняться в фоновом режиме. Вызывающая корутина может продолжить выполнять инструкции вместо того, чтобы ожидать возврата управления от другой корутины.
Объект Task не может существовать сам по себе. В него обязательно должна быть обёрнута корутина.
В результате получается, что объект Task, представляющий задачу — это корутина, но корутина — это не задача.

### Сравнение корутин и потоков
- Корутины «легче» потоков. Корутина объявляется в виде функции.
- Поток — это объект, который создаёт и которым управляет операционная система. Он представлен в Python объектом threading.Thread.

> Получается, что обычно корутины создаются и начинают выполняться быстрее потоков, и что они занимают меньше памяти. И наоборот — потоки создаются и запускаются медленнее корутин и требуют больше системных ресурсов.

> Корутины выполняются в пределах одного потока, в результате один поток может выполнять код множества корутин.

### Сравнение корутин и процессов
- Корутины «легче» процессов. На самом же деле — даже потоки «легче» процессов».
- Процесс — это компьютерная программа. У неё может быть один или большее количество потоков. (Python-процесс — это отдельный экземпляр Python-интерпретатора.)
- Процессы, как и потоки, создаёт операционная система, она же ими управляет. Они представлены объектом multiprocessing.Process.

> Это значит, что корутины создаются и запускаются гораздо быстрее процессов, и то, что они требуют гораздо меньше памяти. Корутина — это всего лишь особая функция, а процесс — это экземпляр интерпретатора, в котором имеется по меньшей мере один поток.

### Определение, создание и запуск корутин
Функция корутины, после того, как она определена, может быть использована для создания объекта корутины. Модуль asyncio даёт нам средства для запуска объектов корутин в цикле событий, который представляет собой среду выполнения для корутин.

```python
Корутину можно определить посредством выражения async def.
Это — расширение выражения def, предназначенного для определения подпрограмм.
Оно определяет корутину, которая может быть создана, и возвращает объект корутины.

# определение корутины
async def coro()
    ...
```

Затем в пределах корутины могут использоваться выражения, специфичные для корутин, такие, как await, async for и async with.
```python
# определение корутины
async def coro():
    # ожидание другой корутины
    await asyncio.sleep(1)
```

После того, как корутина определена, её можно создать. Выглядит это как вызов функции. В ходе работы этой команды корутина не запускается. Эта команда возвращает объект корутины.
```python
...
# создание корутины
coroutine = coro()
```

У Python-объекта корутины есть методы — такие, как send() и close(). Он имеет тип coroutine.
```python
import asyncio

async def foo():
    await asyncio.sleep(1)

coroutine = foo()
print(type(coro))
<class 'coroutine'>
sys:1: RuntimeWarning: coroutine 'custom_coro' was never awaited --> below why
```

### Как запустить корутину из Python-кода
Корутины можно определять и создавать в обычном Python-коде, но запускать их можно только в цикле событий.

- Цикл событий — это база любого asyncio-приложения. Цикл событий выполняет асинхронные задачи и коллбэки, сетевые операции ввода/вывода, подпроцессы.
- Цикл событий, выполняющий корутины, организует работу кооперативной многозадачности, применяемой корутинами.
- Типичный способ запуска цикла событий для корутин заключается в использовании функции asyncio.run()
    - Эта функция принимает одну корутину и возвращает значение корутины. Предоставленная ей корутина может быть использована как точка входа в программу, основанную на корутинах.

```python
import asyncio

# определение корутины
async def foo():
    await asyncio.sleep(1)

# главная корутина
async def main():
    # выполнение нашей корутины
    await foo()

# запуск программы, основанной на корутинах
asyncio.run(main())
```

## Что такое цикл событий asyncio
Цикл событий — это среда для выполнения корутин в `одном потоке`.

Он отвечает за решение множества задач. Вот некоторые из них:
- Выполнение корутин.
- Выполнение коллбэков.
- Выполнение сетевых операций ввода/вывода.
- Выполнение подпроцессов.

Цикл событий, как видно из его названия, это — цикл. Он управляет списком задач (корутин) и стремится продвинуть выполнение каждой из них в определённой последовательности на каждой своей итерации. Он, кроме того, выполняет и другие задачи — наподобие выполнения коллбэков и обработки операций ввода/вывода

### Запуск цикла событий и получение ссылки на его объект
Обычно в asyncio-приложениях ссылки на объекты циклов событий получают, вызывая функцию asyncio.run().
> Эта функция всегда создаёт новый цикл событий и в конце завершает его работу. Её следует использовать как основную точку входа для asyncio-программ, в идеале её нужно вызывать в программах лишь один раз.

Существуют и низкоуровневые функции для создания цикла событий и для работы с ним. Функция asyncio.new_event_loop() создаёт новый цикл событий и возвращает ссылку на него.
```python
import asyncio

# создаём новый цикл событий asyncio и обеспечиваем доступ к нему
loop = asyncio.new_event_loop()
```

Если цикл событий asyncio уже выполняется — доступ к нему можно получить посредством функции asyncio.get_running_loop().
```python
import asyncio

# создаём новый цикл событий asyncio и обеспечиваем доступ к нему
loop = asyncio.new_event_loop()
...
# получаем доступ к выполняющемуся циклу событий
info = asyncio.get_runnin_loop()
```

### Подробности об объекте цикла событий
Цикл событий реализован в виде Python-объекта. Этот объект определяет реализацию цикла событий, он предоставляет стандартный API, предназначенный для взаимодействия с циклом, описанный в классе AbstractEventLoop.
Например, в ОС семейства Windows и Unix цикл событий будет реализован по-разному из-за различных внутренних механизмов реализации неблокирующего ввода/вывода на этих платформах.

- SelectorEventLoop — это цикл событий, используемый по умолчанию в ОС, основанных на Unix — наподобие Linux и macOS.
- ProactorEventLoop — это цикл событий, по умолчанию используемый в Windows.

### Зачем может понадобиться доступ к циклу событий
- Для мониторинга хода выполнения задач.
- Для выдачи и получения результатов работы задач.
- Для запуска одноразовых задач.

Цикл событий asyncio может использоваться в программах как альтернатива пулу потоков, рассчитанная на работу с задачами, основанными на корутинах.

## Создание и запуск asyncio-задач
Объекты Task (задачи) в asyncio-программах можно создавать из корутин. Задачи предоставляют инструменты, предназначенные для независимого планирования и выполнения корутин. Они позволяют ставить задачи в очередь и отменять их, получать в нужное время результаты их работы и выданные ими исключения. 

Цикл событий asyncio управляет задачами. Получается, что все корутины в цикле событий становятся задачами, работа с ними тоже ведётся как с задачами.

### Что такое asyncio-задача
- Task — это объект, который отвечает за планирование выполнения asyncio-корутин и за их независимый запуск.
- Задачи создают из корутин. Для создания задачи нужен объект корутины. Задача оборачивает корутину, планирует её выполнение и даёт средства для взаимодействия с ней.
- Задачи выполняются независимо друг от друга. Это значит, что их выполнение планируется в цикле событий asyncio, и что они выполняются независимо от того, что ещё происходит в создавшей их корутине. Это отличается от прямого выполнения корутины, когда вызывающая сторона должна дождаться её завершения.
- Класс asyncio.Task расширяет класс asyncio.Future, его экземпляры являются объектами, допускающими ожидание.

```python
Так как Task — это объект, допускающий ожидание, получается, что корутина может подождать завершения задачи с использованием выражения await.

...
подождать завершения задачи
await task
```

### Как создать задачу
Задачи создают с использованием экземпляра корутины, предоставленного соответствующему механизму.

```python
# определение корутины
async def task_coroutine():
    # ...
```

Есть два основных способа создания и планирования задач:
- Создать объект Task с использованием высокоуровневого API (предпочтительный способ).
- Создать объект Task с помощью низкоуровневого API.

```python
Создать объект Task с использованием высокоуровневого API (предпочтительный способ).

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# создание корутины
coro = task_coroutine()
# создание задачи из корутины
task = asyncio.create_task(coro)  # returns asyncio.Task
```

```python
Создать объект Task с помощью низкоуровневого API.

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# создание задачи и планирование её выполнения
task = asyncio.ensure_future(task_coroutine())

#############################################
Создать объект Task с помощью низкоуровневого API.

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# получить текущий цикл событий
loop = asyncio.get_event_loop()
# создать задачу и запланировать её выполнение
task = loop.create_task(task_coroutine())
```

### Когда запускаются задачи?
Хотя мы можем планировать независимый запуск корутин в виде задач, пользуясь функцией create_task(), задача может не запуститься немедленно. На самом деле, задача не будет запущена до тех пор, пока у цикла событий не появится возможность её запустить. Это произойдёт тогда, когда все другие корутины перестанут выполняться и настанет очередь интересующей нас задачи.
```python
...
# создание задачи из корутины
task = asyncio.create_task(task_coroutine())
# ожидание задачи, что позволяет ей запуститься
await task
```