# Wunder Fund reads
Рассмотрим
- Определение, создание и запуск корутин.
- Асинхронное программирование в Python.
- Организация неблокирующего ввода-вывода.
- Средства конкурентного программирования, используемые при работе с корутинами.

### Асинхронные задачи
Слово «асинхронный» используют для описания неких процессов, не совпадающих друг с другом во времени. Его противоположность — слово «синхронный», используемое для описания чего-либо, точно совпадающего во времени.

### Асинхронный вызов функции
Асинхронный вызов функции — это запрос на вызов функции, выполняемый неким образом в некий момент времени, при этом вызывающая сторона, после выполнения вызова, может продолжать работу и решать другие задачи.

### Объект future
Выполнение асинхронного вызова функции часто приводит к предоставлении вызывающей стороне некоего идентификатора запроса, который вызывающая сторона может использовать для того, чтобы проверить состояние запроса или получить результаты. Такие идентификаторы часто называют объектами, ждущими результата выполнения задачи (future, объект Future, преднамеченное значение, «футура»).

Объект future: идентификатор асинхронного вызова функции, позволяющий проверять состояние вызова и получать результаты работы функции.

### Объект task
Комбинацию асинхронного вызова функции и объекта Future часто называют асинхронной задачей. Это так из-за того, что такая комбинация даёт больше возможностей, чем обычный вызов функции. Например — позволяет отменять запрос и выполнять другие действия.

Асинхронная задача: этот термин используется для обозначения сущности, представляющей собой объединение асинхронного вызова функции и порождённого этим вызовом объекта Future.

### Асинхронное программирование
В широком смысле асинхронное программирование в Python — это выполнение запросов без блокировки основной программы ради ожидания их завершения. Всё это реализовано с использованием корутин. Они выполняются в `цикле событий, а сам он выполняется в единственном потоке`.

Если говорить о других подобных механизмах — то в Python можно работать с потоками и процессами, которые способны асинхронно выполнять задачи. Например, один поток может запустить другой поток для выполнения вызова функции, а после этого продолжить выполнять другие действия. Операционная система запланирует и выполнит второй поток в некий момент времени, а первый поток может, по желанию программиста, проверить состояние задачи, или может этого не делать.

Python даёт в наше распоряжение пулы потоков и процессов, основанные на концепции исполнителей. Реализовано это, соответственно, посредством классов ThreadPoolExecutor и ProcessPoolExecutor. Эти классы используют одинаковый интерфейс и поддерживают асинхронные задачи с помощью метода submit(), который возвращает объект Future.

### Корутины
Корутина — это функция, выполнение которой можно приостановить и возобновить.

Корутину можно определить с использованием выражения async def. Она может принимать аргументы и возвращать значение — так же, как и функция.
```python
async def coro():
    ...

...
создание объекта корутины
coro = custom_coro()

...
приостановить выполнение кода и запланировать выполнение целевого объекта
await custom_coro()
```

Асинхронный итератор — это итератор, который выдаёт объекты, допускающие ожидание.
> Асинхронный итератор: объект, который реализует методы aiter() и anext(). Метод anext() должен возвращать объект, допускающий ожидание. Конструкция async for разрешает объекты, допускающие ожидание, возвращённые методом anext() асинхронного итератора до тех пор, пока он не вызовет исключение StopAsyncIteration.
```python
...
обход асинхронного итератора
async for item in async_iterator:
    print(item)
```
> Применение этой конструкции не приводит к параллельному выполнению цикла for. Вместо этого вызывающая корутина, которая выполняет цикл for, будет приостанавливаться и самостоятельно ожидать каждый объект, допускающий ожидание, полученный из итератора.


## asyncio
Центральной концепцией модуля asyncio является цикл событий. Это — механизм, который выполняет программы, основанные на корутинах, и реализует кооперативную многозадачность корутин.

Когда стоит использовать модуль asyncio:
    - Чтобы применять в программе корутины.
    - Чтобы воспользоваться парадигмой асинхронного программирования.
    - Чтобы использовать неблокирующую обработку ввода/вывода.

> Конкурентность, основанная на потоках, доступна Python-программистам благодаря модулю threading, она поддерживается на уровне операционной системы, в которой работает Python-программа. Такая конкурентность подходит для обработки блокирующих операций ввода/вывода, таких, как запись и чтение данных при работе с файлами, сокетами, устройствами.

> Конкурентность, основанная на процессах, реализуется на основе механизмов из модуля multiprocessing. Её, как и в случае с потоками, поддерживает операционная система. Она подходит для решения задач, скорость выполнения которых привязана к производительности CPU, но которые при этом не предусматривают интенсивного межпроцессного взаимодействия. Это, например, тяжёлые вычислительные задачи.

> Корутины — это альтернатива потокам и процессам. Программисту их предоставляет сам язык Python и среда его выполнения (стандартный интерпретатор), а их поддержка основана на модуле asyncio. Они подходят для обработки неблокируюих операций ввода/вывода с использованием подпроцессов и сокетов. Впрочем, заниматься блокирующим вводом/выводом и решать тяжёлые вычислительные задачи можно, используя подход, имитирующий решение неблокирующих задач, когда в недрах программы всё сводится к применению потоков и процессов.


```
Потоки и процессы позволяют достичь многозадачности через механизмы операционной системы, которая решает — какой поток или процесс надо запустить, когда его надо запустить, сколько процессорного времени ему дать. Операционная система быстро переключается между потоками и процессами, приостанавливая те, которые отработали отведённое им время, и возобновляя выполнение тех, которым выделено время на работу. Это называют вытесняющей многозадачностью.

А корутины в Python реализуют альтернативный подход к многозадачности — кооперативную многозадачность. Корутины — это подпрограммы (функции), выполнение которых можно приостанавливать и возобновлять. Их выполнение приостанавливается с помощью выражения await, а возобновляется после того, как это выражение разрешится. Корутины задуманы именно такими, это позволяет им кооперироваться, решая — когда и где приостановить выполнение.

Они «легче» потоков. То есть — быстрее запускаются и используют меньше памяти. В сущности, корутины — это особая разновидность функций, а вот потоки представлены Python-объектами и связаны с потоками в операционной системе, с которыми эти объекты должны взаимодействовать.

В силу этого в Python-программе могут использоваться тысячи потоков. А если говорить о корутинах, то их уже может быть десятки или сотни тысяч, все они будут размещены в одном потоке.
```

```
Как мы уже видели, корутины могут выполнять неблокирующие операции ввода/вывода асинхронно. Но модуль asyncio, кроме того, даёт нам возможность выполнять в асинхронном стиле блокирующие операции ввода/вывода и задачи, скорость выполнения которых привязана к производительности CPU. Делается это путём имитации неблокирующих механизмов в недрах системы посредством потоков и процессов.
```


## Еще про корутины
Корутина (coroutine, сопрограмма) — это функция, выполнение которой может быть приостановлено и возобновлено. Подпрограмму можно запустить, её работа начнётся в одном месте и завершится в другом. А корутину можно запустить, потом — приостановить, потом — возобновить. Приостанавливать и возобновлять выполнение корутины можно много раз — до того момента, пока её работа не будет, в итоге, завершена. В частности, корутины могут управлять тем, где именно они приостанавливают своё выполнение. Для этого может привлекаться специфическое выражение — такое, как await, похожее на выражение yield, применяемое в Python-генераторах.

Одновременно можно создавать и запускать множество корутин. У них есть `средства управления` тем, когда они `приостанавливают и возобновляют` своё выполнение, что позволяет им `кооперироваться относительно того, когда выполняются конкурентные задачи`. Это называют `кооперативной многозадачностью`. Такой подход к многозадачности `отличается от вытесняющей многозадачности`, обычно используемой при работе с потоками.

> …для организации конкурентного выполнения множества приложений `процессы добровольно уступают контроль другим приложениям`, делая это либо через некие промежутки времени, либо тогда, когда они простаивают или логически заблокированы. Этот тип многозадачности называют кооперативной многозадачностью из-за того, что все программы должны кооперироваться для того чтобы обеспечить работу схемы планирования их выполнения.

> Реализация `вытесняющей многозадачности` предусматривает участие `операционной системы в принятии решений` о том, какой поток и когда нужно приостановить или возобновить. Это отличается от подхода, применяемого в кооперативной многозадачности, когда задачи сами принимают подобные решения.


### Сравнение корутин и задач
Подпрограммы и корутины могут представлять в программах «задачи». Но в Python есть особый объект, представляющий задачу. Это — объект asyncio.Task.
Корутину можно обернуть в объект asyncio.Task и выполнить независимо — в противовес её выполнению напрямую, внутри другой корутины. Объект Task даёт средства для асинхронного выполнения корутин.

Задача: обёрнутая корутина, которая может быть выполнена независимо.
Это позволяет обёрнутой корутине выполняться в фоновом режиме. Вызывающая корутина может продолжить выполнять инструкции вместо того, чтобы ожидать возврата управления от другой корутины.
Объект Task не может существовать сам по себе. В него обязательно должна быть обёрнута корутина.
В результате получается, что объект Task, представляющий задачу — это корутина, но корутина — это не задача.

### Сравнение корутин и потоков
- Корутины «легче» потоков. Корутина объявляется в виде функции.
- Поток — это объект, который создаёт и которым управляет операционная система. Он представлен в Python объектом threading.Thread.

> Получается, что обычно корутины создаются и начинают выполняться быстрее потоков, и что они занимают меньше памяти. И наоборот — потоки создаются и запускаются медленнее корутин и требуют больше системных ресурсов.

> Корутины выполняются в пределах одного потока, в результате один поток может выполнять код множества корутин.

### Сравнение корутин и процессов
- Корутины «легче» процессов. На самом же деле — даже потоки «легче» процессов».
- Процесс — это компьютерная программа. У неё может быть один или большее количество потоков. (Python-процесс — это отдельный экземпляр Python-интерпретатора.)
- Процессы, как и потоки, создаёт операционная система, она же ими управляет. Они представлены объектом multiprocessing.Process.

> Это значит, что корутины создаются и запускаются гораздо быстрее процессов, и то, что они требуют гораздо меньше памяти. Корутина — это всего лишь особая функция, а процесс — это экземпляр интерпретатора, в котором имеется по меньшей мере один поток.

### Определение, создание и запуск корутин
Функция корутины, после того, как она определена, может быть использована для создания объекта корутины. Модуль asyncio даёт нам средства для запуска объектов корутин в цикле событий, который представляет собой среду выполнения для корутин.

```python
Корутину можно определить посредством выражения async def.
Это — расширение выражения def, предназначенного для определения подпрограмм.
Оно определяет корутину, которая может быть создана, и возвращает объект корутины.

# определение корутины
async def coro()
    ...
```

Затем в пределах корутины могут использоваться выражения, специфичные для корутин, такие, как await, async for и async with.
```python
# определение корутины
async def coro():
    # ожидание другой корутины
    await asyncio.sleep(1)
```

После того, как корутина определена, её можно создать. Выглядит это как вызов функции. В ходе работы этой команды корутина не запускается. Эта команда возвращает объект корутины.
```python
...
# создание корутины
coroutine = coro()
```

У Python-объекта корутины есть методы — такие, как send() и close(). Он имеет тип coroutine.
```python
import asyncio

async def foo():
    await asyncio.sleep(1)

coroutine = foo()
print(type(coro))
<class 'coroutine'>
sys:1: RuntimeWarning: coroutine 'custom_coro' was never awaited --> below why
```

### Как запустить корутину из Python-кода
Корутины можно определять и создавать в обычном Python-коде, но запускать их можно только в цикле событий.

- Цикл событий — это база любого asyncio-приложения. Цикл событий выполняет асинхронные задачи и коллбэки, сетевые операции ввода/вывода, подпроцессы.
- Цикл событий, выполняющий корутины, организует работу кооперативной многозадачности, применяемой корутинами.
- Типичный способ запуска цикла событий для корутин заключается в использовании функции asyncio.run()
    - Эта функция принимает одну корутину и возвращает значение корутины. Предоставленная ей корутина может быть использована как точка входа в программу, основанную на корутинах.

```python
import asyncio

# определение корутины
async def foo():
    await asyncio.sleep(1)

# главная корутина
async def main():
    # выполнение нашей корутины
    await foo()

# запуск программы, основанной на корутинах
asyncio.run(main())
```

## Что такое цикл событий asyncio
Цикл событий — это среда для выполнения корутин в `одном потоке`.

Он отвечает за решение множества задач. Вот некоторые из них:
- Выполнение корутин.
- Выполнение коллбэков.
- Выполнение сетевых операций ввода/вывода.
- Выполнение подпроцессов.

Цикл событий, как видно из его названия, это — цикл. Он управляет списком задач (корутин) и стремится продвинуть выполнение каждой из них в определённой последовательности на каждой своей итерации. Он, кроме того, выполняет и другие задачи — наподобие выполнения коллбэков и обработки операций ввода/вывода

### Запуск цикла событий и получение ссылки на его объект
Обычно в asyncio-приложениях ссылки на объекты циклов событий получают, вызывая функцию asyncio.run().
> Эта функция всегда создаёт новый цикл событий и в конце завершает его работу. Её следует использовать как основную точку входа для asyncio-программ, в идеале её нужно вызывать в программах лишь один раз.

Существуют и низкоуровневые функции для создания цикла событий и для работы с ним. Функция asyncio.new_event_loop() создаёт новый цикл событий и возвращает ссылку на него.
```python
import asyncio

# создаём новый цикл событий asyncio и обеспечиваем доступ к нему
loop = asyncio.new_event_loop()
```

Если цикл событий asyncio уже выполняется — доступ к нему можно получить посредством функции asyncio.get_running_loop().
```python
import asyncio

# создаём новый цикл событий asyncio и обеспечиваем доступ к нему
loop = asyncio.new_event_loop()
...
# получаем доступ к выполняющемуся циклу событий
info = asyncio.get_runnin_loop()
```

### Подробности об объекте цикла событий
Цикл событий реализован в виде Python-объекта. Этот объект определяет реализацию цикла событий, он предоставляет стандартный API, предназначенный для взаимодействия с циклом, описанный в классе AbstractEventLoop.
Например, в ОС семейства Windows и Unix цикл событий будет реализован по-разному из-за различных внутренних механизмов реализации неблокирующего ввода/вывода на этих платформах.

- SelectorEventLoop — это цикл событий, используемый по умолчанию в ОС, основанных на Unix — наподобие Linux и macOS.
- ProactorEventLoop — это цикл событий, по умолчанию используемый в Windows.

### Зачем может понадобиться доступ к циклу событий
- Для мониторинга хода выполнения задач.
- Для выдачи и получения результатов работы задач.
- Для запуска одноразовых задач.

Цикл событий asyncio может использоваться в программах как альтернатива пулу потоков, рассчитанная на работу с задачами, основанными на корутинах.

## Создание и запуск asyncio-задач
Объекты Task (задачи) в asyncio-программах можно создавать из корутин. Задачи предоставляют инструменты, предназначенные для независимого планирования и выполнения корутин. Они позволяют ставить задачи в очередь и отменять их, получать в нужное время результаты их работы и выданные ими исключения. 

Цикл событий asyncio управляет задачами. Получается, что все корутины в цикле событий становятся задачами, работа с ними тоже ведётся как с задачами.

### Что такое asyncio-задача
- Task — это объект, который отвечает за планирование выполнения asyncio-корутин и за их независимый запуск.
- Задачи создают из корутин. Для создания задачи нужен объект корутины. Задача оборачивает корутину, планирует её выполнение и даёт средства для взаимодействия с ней.
- Задачи выполняются независимо друг от друга. Это значит, что их выполнение планируется в цикле событий asyncio, и что они выполняются независимо от того, что ещё происходит в создавшей их корутине. Это отличается от прямого выполнения корутины, когда вызывающая сторона должна дождаться её завершения.
- Класс asyncio.Task расширяет класс asyncio.Future, его экземпляры являются объектами, допускающими ожидание.

```python
Так как Task — это объект, допускающий ожидание, получается, что корутина может подождать завершения задачи с использованием выражения await.

...
подождать завершения задачи
await task
```

### Как создать задачу
Задачи создают с использованием экземпляра корутины, предоставленного соответствующему механизму.

```python
# определение корутины
async def task_coroutine():
    # ...
```

Есть два основных способа создания и планирования задач:
- Создать объект Task с использованием высокоуровневого API (предпочтительный способ).
- Создать объект Task с помощью низкоуровневого API.

```python
Создать объект Task с использованием высокоуровневого API (предпочтительный способ).

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# создание корутины
coro = task_coroutine()
# создание задачи из корутины
task = asyncio.create_task(coro)  # returns asyncio.Task
```

```python
Создать объект Task с помощью низкоуровневого API.

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# создание задачи и планирование её выполнения
task = asyncio.ensure_future(task_coroutine())

#############################################
Создать объект Task с помощью низкоуровневого API.

import asyncio

async def task_coroutine():
    await asyncio.sleep(1)

# получить текущий цикл событий
loop = asyncio.get_event_loop()
# создать задачу и запланировать её выполнение
task = loop.create_task(task_coroutine())
```

### Когда запускаются задачи?
Хотя мы можем планировать независимый запуск корутин в виде задач, пользуясь функцией create_task(), задача может не запуститься немедленно. На самом деле, задача не будет запущена до тех пор, пока у цикла событий не появится возможность её запустить. Это произойдёт тогда, когда все другие корутины перестанут выполняться и настанет очередь интересующей нас задачи.
```python
...
# создание задачи из корутины
task = asyncio.create_task(task_coroutine())
# ожидание задачи, что позволяет ей запуститься
await task
```

### Жизненный цикл задачи
С asyncio-объектом Task связано такое понятие, как жизненный цикл.

Для начала отметим, что задачи создают из корутин. Затем планируют их независимое выполнение в цикле событий. В результате, в некий момент времени, запланированная задача выполняется. В процессе её выполнения она может быть приостановлена, например — при ожидании выполнения другой корутины или задачи. Её работа может завершиться нормально и возвратить результат. Возможно и такое, что её работа завершится неудачно, с выдачей исключения.

Жизненный цикл задачи можно представить себе так:
1. Создана (Created).
2. Запланирована (Scheduled).
3. Выполняется (Running).
4. Завершена (Done).

Обратите внимание на то, что такие пункты нашего списка, как «Приостановлена», «Вернула результат», «Выдала исключение» и «Отменена» — это, сами по себе, не состояния задачи. Это — важные переходные моменты жизненного цикла выполняющейся задачи.

### Как проверить состояние задачи
После того, как объект Task создан — можно проверить состояние задачи. В состоянии задачи есть два интересующих нас значения, дающих следующие сведения:
- Завершено ли выполнение задачи.
- Отменено ли выполнение задачи.

```python
...
# проверка на завершение выполнения задачи
if task.done():
    # ...
```

Выполнение задачи будет завершено в следующих случаях:
- Выполнение корутины завершилось нормально.
- Корутина явным образом вернула результат.
- Корутина выдала неожиданную ошибку или неожиданное исключение.
- Выполнение задачи отменено.

### Проверка на отмену выполнения задачи
```python
...
# проверка на отмену выполнения задачи
if task.cancelled():
    # ...
```

Задача будет отменена в том случае, если был вызван её метод cancel(), и если он был успешно завершён. То есть — если этот метод вернул True.

### Как получить результат выполнения задачи
```python
...
# получение возвращённого значения из обёрнутой корутины
value = task.result()
```

Если корутина выдаёт необработанную ошибку — она выдаётся снова при вызове result() и её может понадобиться обработать. То же касается и исключений:
```python
...
try:
    # получение возвращённого значения из обёрнутой корутины
    value = task.result()
except Exception:
    # задача завершилась неудачно, результата нет
```

Если задача была отменена — при вызове метода result() выдаётся исключение CancelledError. Это исключение может нуждаться в обработке:
```python
...
try:
    # получение возвращённого значения из обёрнутой корутины
    value = task.result()
except asyncio.CancelledError:
    # задача была отменена
```

```python
...
# проверка того, не была ли отменена задача
if not task.cancelled():
    # получение возвращённого значения из обёрнутой корутины
    value = task.result()
else:
    # задача была отменена


...
try:
    # получение возвращённого значения из обёрнутой корутины
    value = task.result()
except asyncio.InvalidStateError:
    # выполнение задачи ещё не завершено


...
# проверка того, завершено ли выполнение задачи
if not task.done():
    await task
# получение возвращённого значения из обёрнутой корутины
value = task.result()
```

### Как получить исключение, выданное задачей
Корутина, обёрнутая задачей, может вызвать исключение, которое окажется необработанным. Это приведёт к отмене задачи.
```python
...
# получение исключения, вызванного задачей
exception = task.exception()


...
try:
    # получение исключения, вызванного задачей
    exception = task.exception()
except asyncio.CancelledError:
    # задача была отменена


...
# проверка того, не была ли отменена задача
if not task.cancelled():
    # получение исключения, вызванного задачей
    exception = task.exception()
else:
    # задача была отменена


...
try:
    # получение исключения, вызванного задачей
    exception = task.exception()
except asyncio.InvalidStateError:
    # выполнение задачи ещё не завершено


...
# проверка того, не было ли завершено выполнение задачи
if not task.done():
    await task
# получение исключения, выданного задачей
exception = task.exception()
```

### Как отменить выполнение задачи
Отменить выполнение запланированной задачи можно, воспользовавшись её методом cancel().
Он вернёт True в том случае, если ему удалось отменить задачу, а в противном случае он вернёт False
```python
...
# отмена задачи
was_cancelled = task.cancel()
```

Если выполнение задачи уже завершено — её нельзя отменить. В такой ситуации метод cancel() вернёт False, а задаче не будет назначено состояние, указывающее на то, что она была отменена.
В следующий раз, когда у задачи будет возможность выполниться, она вызовет исключение CancelledError.

Если исключение CancelledError не будет обработано в обёрнутой задачей корутине — выполнение задачи будет отменено. 

В противном случае, если это исключение будет обработано в корутине — задача отменена не будет.
Метод cancel() может принимать аргумент, содержащий сообщение, которое будет использовано в качестве содержимого исключения CancelledError.

### Как использовать коллбэки при работе с задачами
Задачу можно оснастить коллбэком, вызываемым при её завершении, воспользовавшись методом add_done_callback().

Этот метод принимает имя функции, которую нужно вызвать после завершения выполнения задачи.
Функция-коллбэк должна принимать в качестве аргумента экземпляр класса Task
```python
# функция-коллбэк, вызываемая после завершения работы задачи
def handle(task):
    print(task)
 
...
# регистрация коллбэка
task.add_done_callback(handle)
```

Вспомните о том, что задача может быть завершена в том случае, если обёрнутая ей корутина нормально завершила работу и вернула значение, когда произошло необработанное исключение, или когда задача была отменена.

Метод add_done_callback() может использоваться для добавления к задаче или регистрации любого необходимого количества функций-коллбэков.

Удалять или отменять регистрацию коллбэков можно, воспользовавшись методом remove_done_callback()
```python
...
удаление коллбэка, вызываемого при завершении задачи
task.remove_done_callback(handle)
```

### Текущие и выполняющиеся задачи
```python
...
# получение текущей задачи
task = asyncio.current_task()

...
# получение всех задач
tasks = asyncio.all_tasks()
```

```python
# пример получения текущей задачи из главной корутины

import asyncio

# определение главной корутины
async def main():
    print('main coroutine started')
    # получение текущей задачи
    task = asyncio.current_task()
    # вывод сведений о ней
    print(task)

# запуск asyncio-программы
asyncio.run(main())

После запуска этого примера сначала создаётся главная корутина, которая используется для запуска asyncio-программы. Корутина main() запускается и первым делом выводит сообщение. Затем она получает текущую задачу — объект Task, представляющий саму эту корутину, которая выполняется в данный момент. Потом программа выводит сведения о текущей выполняемой задаче.
```

```python
# пример, где запускают множество задач, а после этого получают к ним доступ

import asyncio


async def task_coroutine(value):
    print(f'task {value} is running')
    # краткая блокировка
    await asyncio.sleep(1)


# определение главной корутины
async def main():
    print('main coroutine started')
    # запуск нескольких задач
    started_tasks = [asyncio.create_task(task_coroutine(i)) for i in range(10)]
    
    # выделение времени, необходимого на то, чтобы некоторые из задач запустились
    await asyncio.sleep(0.1)
    
    # получение всех задач
    tasks = asyncio.all_tasks()
    
    # вывод сведений обо всех задачах
    for task in tasks:
        print(f'> {task.get_name()}, {task.get_coro()}')

    # ждём завершения всех задач
    for task in started_tasks:
        await task

# запуск asyncio-программы
asyncio.run(main())

######################
main coroutine started
task 0 is running
task 1 is running
task 2 is running
task 3 is running
task 4 is running
task 5 is running
task 6 is running
task 7 is running
task 8 is running
task 9 is running
> Task-9, <coroutine object task_coroutine at 0x10e186e30>
> Task-2, <coroutine object task_coroutine at 0x10e184e40>
> Task-11, <coroutine object task_coroutine at 0x10e186f10>
> Task-7, <coroutine object task_coroutine at 0x10e186d50>
> Task-4, <coroutine object task_coroutine at 0x10e185700>
> Task-10, <coroutine object task_coroutine at 0x10e186ea0>
> Task-8, <coroutine object task_coroutine at 0x10e186dc0>
> Task-5, <coroutine object task_coroutine at 0x10e186ab0>
> Task-1, <coroutine object main at 0x10e1847b0>
> Task-3, <coroutine object task_coroutine at 0x10e184f90>
```
